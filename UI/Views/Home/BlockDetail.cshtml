@{
    ViewData["Title"] = "Block Detail";
    var apiBaseUrl = "https://localhost:7174/";
    var blockId = ViewBag.BlockId;
    var isPublic = ViewBag.IsPublic;
}

<!-- Load Blockly script early -->
<script src="https://unpkg.com/blockly/blockly.min.js"></script>

<div class="container mt-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <div>
            <h2 id="blockTitle">Loading...</h2>
            <div id="blockMeta" class="text-muted"></div>
        </div>
        <div>
            <a href="@Url.Action(ViewBag.IsPublic ? "SharedBlocks" : "MyBlocks", "Home")" class="btn btn-outline-secondary me-2">
                <i class="bi bi-arrow-left"></i> Back to @(ViewBag.IsPublic ? "Shared" : "My") Blocks
            </a>
            <button id="starBtn" class="btn btn-outline-warning me-2" onclick="starBlock()" style="display: none;" title="Star this block">
                <i class="bi bi-star"></i> Star
            </button>
            <button id="forkBtn" class="btn btn-outline-info me-2" onclick="forkBlock()" style="display: none;" title="Fork this block">
                <i class="bi bi-arrow-up-right-square"></i> Fork
            </button>
            <button id="settingsBtn" class="btn btn-outline-primary me-2" onclick="openSettings()" style="display: none;">
                <i class="bi bi-gear"></i> Settings
            </button>
            <button id="editModeBtn" class="btn btn-primary" onclick="toggleEditMode()" style="display: none;">
                <i class="bi bi-pencil"></i> <span id="editBtnText">Edit</span>
            </button>
        </div>
    </div>

    <div id="loadingState" class="text-center py-5">
        <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Loading block...</p>
    </div>

    <div id="blockContent" style="display: none;">
        <div id="blocklyDiv" style="height: 400px; width: 100%; margin-bottom: 10px; border: 1px solid #ddd;"></div>
        
        <!-- View Mode Controls -->
        <div id="viewControls" class="mb-3">
            <button onclick="exportJson()" class="btn btn-secondary">Export</button>
            <button onclick="sendToApi()" class="btn btn-info ms-2">Generate Code</button>
            <span id="apiStatus" class="ms-3"></span>
        </div>
        
        <!-- Edit Mode Controls -->
        <div id="editControls" class="mb-3" style="display: none;">
            <button onclick="exportJson()" class="btn btn-secondary">Export</button>
            <button onclick="sendToApi()" class="btn btn-info ms-2">Generate Code</button>
            <button onclick="cancelEdit()" class="btn btn-outline-secondary ms-2">Cancel</button>
            <button onclick="saveChanges()" class="btn btn-success ms-2">Save Changes</button>
            <span id="editApiStatus" class="ms-3"></span>
        </div>
        
        <div style="position:relative;">
            <pre id="codeDisplay" style="background:#f8f9fa; padding:1em; margin-top:1em; white-space:pre-wrap; word-break:break-all;"></pre>
            <button id="copyCodeBtn" title="Copy code" style="position:absolute;top:10px;right:10px;z-index:2;background:transparent;border:none;">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="#888" viewBox="0 0 16 16">
                    <rect width="10" height="12" x="3" y="2" rx="2" fill="#eee" stroke="#888" stroke-width="1"/>
                    <rect width="8" height="10" x="4" y="3" rx="1" fill="none" stroke="#888" stroke-width="1"/>
                </svg>
            </button>
        </div>
    </div>
</div>

        </button>
    </div>
</div>

<!-- Real-time Comments Section -->
<div class="card mt-4">
    <div class="card-header">
        <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">
                <i class="bi bi-chat-dots"></i> Comments
                <span id="commentCount" class="badge bg-secondary ms-2">0</span>
            </h5>
            <div class="comment-controls">
                <div class="d-flex align-items-center gap-2">
                    <span class="text-muted small">Sort:</span>
                    <select id="commentSort" class="form-select form-select-sm" style="width: auto;" onchange="updateCommentDisplay()">
                        <option value="newest">Newest first</option>
                        <option value="oldest">Oldest first</option>
                    </select>
                    <span class="text-muted small">Show:</span>
                    <select id="commentLimit" class="form-select form-select-sm" style="width: auto;" onchange="updateCommentDisplay()">
                        <option value="5">5 comments</option>
                        <option value="10">10 comments</option>
                        <option value="20">20 comments</option>
                        <option value="all">All comments</option>
                    </select>
                </div>
            </div>
        </div>
    </div>
    <div class="card-body">
        <!-- Comments List -->
        <div id="commentsList">
            <div id="commentsLoading" class="text-center py-3">
                <div class="spinner-border spinner-border-sm" role="status">
                    <span class="visually-hidden">Loading comments...</span>
                </div>
                <span class="ms-2">Loading comments...</span>
            </div>
            <div id="commentsEmpty" class="text-center text-muted py-4" style="display: none;">
                <i class="bi bi-chat" style="font-size: 2rem;"></i>
                <p class="mt-2 mb-0">No comments yet. Be the first to comment!</p>
            </div>
        </div>
        
        <!-- Show More Button -->
        <div id="showMoreSection" class="text-center mt-3" style="display: none;">
            <button id="showMoreBtn" class="btn btn-outline-secondary btn-sm" onclick="showMoreComments()">
                <i class="bi bi-chevron-down"></i> Show more comments
            </button>
        </div>

        <!-- Comment Input (only show if user is logged in) - Moved to bottom -->
        <div id="commentInputSection" class="mt-4 pt-3 border-top" style="display: none;">
            <div class="d-flex">
                <div class="flex-grow-1 me-2">
                    <textarea id="commentInput" class="form-control" placeholder="Write a comment..." rows="3" maxlength="1000"></textarea>
                    <div class="form-text">
                        <span id="commentCharCount">0</span>/1000 characters
                    </div>
                </div>
                <div class="d-flex flex-column">
                    <button id="submitComment" class="btn btn-primary mb-2" onclick="submitComment()" disabled>
                        <i class="bi bi-send"></i> Comment
                    </button>
                    <button id="cancelComment" class="btn btn-outline-secondary btn-sm" onclick="cancelComment()" style="display: none;">
                        Cancel
                    </button>
                </div>
            </div>
            <div id="commentStatus" class="mt-2"></div>
        </div>
    </div>
</div>

<!-- Update Block Modal -->
<div class="modal fade" id="updateBlockModal" tabindex="-1" aria-labelledby="updateBlockModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="updateBlockModalLabel">Update Block</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="updateBlockForm" onsubmit="return submitUpdateBlock(event)">
            <div class="mb-3">
                <label for="updateBlockName" class="form-label">Block Name</label>
                <input type="text" id="updateBlockName" class="form-control" required maxlength="200" />
            </div>
            <div class="mb-3">
                <label for="updateBlockTags" class="form-label">Tags</label>
                <input type="text" id="updateBlockTags" class="form-control" />
                <div class="form-text">Separate multiple tags with commas</div>
            </div>
            <div class="mb-3">
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="updateBlockPublic" />
                    <label class="form-check-label" for="updateBlockPublic">
                        <i class="bi bi-globe"></i> Make this block public
                    </label>
                    <div class="form-text">Public blocks can be viewed and forked by other users</div>
                </div>
            </div>
            <span id="updateStatus" class="text-danger"></span>
            <div class="mt-3">
                <button type="submit" class="btn btn-primary w-100">Update Block</button>
            </div>
        </form>
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="settingsModalLabel">Block Settings</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="settingsForm" onsubmit="return submitSettings(event)">
            <div class="mb-3">
                <label for="settingsBlockName" class="form-label">Block Name</label>
                <input type="text" id="settingsBlockName" class="form-control" required maxlength="200" />
            </div>
            <div class="mb-3">
                <label for="settingsBlockTags" class="form-label">Tags</label>
                <input type="text" id="settingsBlockTags" class="form-control" />
                <div class="form-text">Separate multiple tags with commas</div>
            </div>
            <div class="mb-3">
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="settingsBlockPublic" />
                    <label class="form-check-label" for="settingsBlockPublic">
                        <i class="bi bi-globe"></i> Make this block public
                    </label>
                    <div class="form-text">Public blocks can be viewed and forked by other users</div>
                </div>
            </div>
            <span id="settingsStatus" class="text-danger"></span>
            <div class="mt-3">
                <button type="submit" class="btn btn-primary w-100">Save Settings</button>
            </div>
        </form>
      </div>
    </div>
  </div>
</div>

<script>
var apiBaseUrl = '@apiBaseUrl';
var blockId = @blockId;
var isPublic = @Json.Serialize(isPublic);
var workspace;
var currentBlock = null;
var isEditMode = false;
var originalBlockContent = null; // Store original content for cancel functionality

const toolbox = `
<xml>
  <category name="Logic" colour="210">
    <block type="controls_if"></block>
    <block type="logic_compare"></block>
    <block type="logic_operation"></block>
    <block type="logic_negate"></block>
    <block type="logic_boolean"></block>
    <block type="logic_null"></block>
    <block type="logic_ternary"></block>
  </category>
  <category name="Loops" colour="120">
    <block type="controls_repeat_ext"></block>
    <block type="controls_whileUntil"></block>
    <block type="controls_for"></block>
    <block type="controls_forEach"></block>
    <block type="controls_flow_statements"></block>
  </category>
  <category name="Math" colour="230">
    <block type="math_number"></block>
    <block type="math_arithmetic"></block>
    <block type="math_single"></block>
    <block type="math_trig"></block>
    <block type="math_constant"></block>
    <block type="math_number_property"></block>
    <block type="math_round"></block>
    <block type="math_modulo"></block>
    <block type="math_random_int"></block>
    <block type="math_random_float"></block>
  </category>
  <category name="Text" colour="160">
    <block type="text"></block>
    <block type="text_join"></block>
    <block type="text_append"></block>
    <block type="text_length"></block>
    <block type="text_isEmpty"></block>
    <block type="text_indexOf"></block>
    <block type="text_charAt"></block>
    <block type="text_getSubstring"></block>
    <block type="text_changeCase"></block>
    <block type="text_trim"></block>
    <block type="text_print"></block>
  </category>
  <category name="Lists" colour="260">
    <block type="lists_create_with"></block>
    <block type="lists_repeat"></block>
    <block type="lists_length"></block>
    <block type="lists_isEmpty"></block>
  </category>
  <sep></sep>
  <category name="Variables" colour="330" custom="VARIABLE"></category>
  <category name="Functions" colour="290" custom="PROCEDURE"></category>
</xml>
`;

document.addEventListener('DOMContentLoaded', function() {
    // Initialize both block loading and comment system
    loadBlock();
    initializeCommentSystem();
});

function loadBlock() {
    const jwt = localStorage.getItem("token");
    
    let apiUrl, headers = {};
    
    if (isPublic) {
        // For public blocks, use the public API endpoint
        apiUrl = apiBaseUrl + "api/blocks/public/" + blockId;
        // Add auth header if user is logged in to get star status
        if (jwt) {
            headers["Authorization"] = "Bearer " + jwt;
        }
    } else {
        // For private blocks, use the regular API endpoint with auth
        if (!jwt) {
            window.location.href = '@Url.Action("Index", "Home")';
            return;
        }
        apiUrl = apiBaseUrl + "api/blocks/" + blockId;
        headers["Authorization"] = "Bearer " + jwt;
    }

    fetch(apiUrl, {
        method: "GET",
        headers: headers
    })
    .then(res => {
        if (!res.ok) {
            throw new Error("Failed to load block");
        }
        return res.json();
    })
    .then(block => {
        currentBlock = block;
        displayBlock(block);
        initializeWorkspace(block);
    })
    .catch(err => {
        console.error("Error loading block:", err);
        document.getElementById('loadingState').innerHTML = 
            '<div class="alert alert-danger">Failed to load block. Please try again.</div>';
    });
}

function displayBlock(block) {
    document.getElementById('blockTitle').textContent = block.name;
    document.getElementById('blockMeta').innerHTML = `
        <div class="mb-2 d-flex align-items-center flex-wrap">
            <span class="badge ${block.isPublic ? 'bg-success' : 'bg-secondary'} me-2">
                <i class="bi ${block.isPublic ? 'bi-globe' : 'bi-lock'}"></i>
                ${block.isPublic ? 'Public' : 'Private'}
            </span>
            ${isPublic ? `<span class="text-muted me-3">
                <i class="bi bi-person"></i> by ${escapeHtml(block.ownerName)}
            </span>` : ''}
            <span class="text-muted me-3">
                <i class="bi bi-star"></i> ${block.starCount}
            </span>
            <span class="text-muted me-3">
                <i class="bi bi-arrow-up-right-square"></i> ${block.forkCount}
            </span>
        </div>
        <div class="mb-2">
            ${block.tags.map(tag => `<span class="badge bg-secondary me-1">${escapeHtml(tag)}</span>`).join('')}
        </div>
        ${block.forkedFromId ? `
        <div class="mb-2">
            <small class="text-success">
                <i class="bi bi-arrow-up-right-square"></i> Forked from 
                <strong>${escapeHtml(block.forkedFromName)}</strong> 
                by ${escapeHtml(block.forkedFromOwnerName)}
            </small>
        </div>
        ` : ''}
        <small>
            <i class="bi bi-calendar"></i> Created: ${new Date(block.createdAt).toLocaleDateString()}
            <i class="bi bi-pencil ms-3"></i> Updated: ${new Date(block.updatedAt).toLocaleDateString()}
        </small>
    `;
    
    document.getElementById('loadingState').style.display = 'none';
    document.getElementById('blockContent').style.display = 'block';
    
    // Show appropriate buttons based on whether this is a public view or user's own block
    if (isPublic) {
        // For public blocks, show star and fork buttons (Phase 2/3 features)
        document.getElementById('starBtn').style.display = 'inline-block';
        document.getElementById('forkBtn').style.display = 'inline-block';
        document.getElementById('editModeBtn').style.display = 'none';
        document.getElementById('settingsBtn').style.display = 'none';
        
        // Update star button state based on whether user has starred this block
        const isStarred = block.isStarredByCurrentUser || false;
        updateStarButton(isStarred, block.starCount);
    } else {
        // For user's own blocks, show edit and settings
        document.getElementById('starBtn').style.display = 'none';
        document.getElementById('forkBtn').style.display = 'none';
        document.getElementById('editModeBtn').style.display = 'inline-block';
        document.getElementById('settingsBtn').style.display = 'inline-block';
    }
}

function initializeWorkspace(block) {
    // Ensure Blockly is loaded before initializing
    if (typeof Blockly === 'undefined') {
        console.error('Blockly is not loaded');
        return;
    }
    
    workspace = Blockly.inject('blocklyDiv', {
        toolbox: toolbox,
        readOnly: true
    });
    
    // Load the block content
    try {
        const blockData = JSON.parse(block.content);
        Blockly.serialization.workspaces.load(blockData, workspace);
    } catch (err) {
        console.error("Error loading block content:", err);
    }
}

function toggleEditMode() {
    // Ensure workspace is initialized
    if (!workspace) {
        console.error('Workspace is not initialized');
        return;
    }
    
    isEditMode = !isEditMode;
    const editBtn = document.getElementById('editBtnText');
    const viewControls = document.getElementById('viewControls');
    const editControls = document.getElementById('editControls');
    
    if (isEditMode) {
        // Store original content for cancel functionality
        originalBlockContent = Blockly.serialization.workspaces.save(workspace);
        
        // Dispose current workspace and create new one in edit mode
        workspace.dispose();
        workspace = Blockly.inject('blocklyDiv', {
            toolbox: toolbox,
            readOnly: false
        });
        
        // Restore content
        Blockly.serialization.workspaces.load(originalBlockContent, workspace);
        
        editBtn.textContent = 'View Only';
        viewControls.style.display = 'none';
        editControls.style.display = 'block';
        document.getElementById('editApiStatus').innerText = '';
    } else {
        // Dispose current workspace and create new one in view mode
        const currentContent = Blockly.serialization.workspaces.save(workspace);
        workspace.dispose();
        workspace = Blockly.inject('blocklyDiv', {
            toolbox: toolbox,
            readOnly: true
        });
        
        // Restore content
        Blockly.serialization.workspaces.load(currentContent, workspace);
        
        editBtn.textContent = 'Edit';
        viewControls.style.display = 'block';
        editControls.style.display = 'none';
        document.getElementById('apiStatus').innerText = '';
    }
}

function exportJson() {
    const json = Blockly.serialization.workspaces.save(workspace);
    document.getElementById("codeDisplay").innerText = JSON.stringify(json, null, 2);
}

function updateBlock() {
    if (!currentBlock) return;
    
    // Pre-fill the modal with current values
    document.getElementById('updateBlockName').value = currentBlock.name;
    document.getElementById('updateBlockTags').value = currentBlock.tags.join(', ');
    document.getElementById('updateBlockPublic').checked = currentBlock.isPublic;
    document.getElementById('updateStatus').innerText = '';
    
    var modal = new bootstrap.Modal(document.getElementById('updateBlockModal'));
    modal.show();
}

function submitUpdateBlock(e) {
    e.preventDefault();
    const jwt = localStorage.getItem("token");
    const blockName = document.getElementById('updateBlockName').value;
    const blockTags = document.getElementById('updateBlockTags').value;
    const isPublic = document.getElementById('updateBlockPublic').checked;
    const status = document.getElementById('updateStatus');
    status.innerText = '';
    
    if (!jwt) {
        status.innerText = 'Please login first.';
        return false;
    }
    
    const json = Blockly.serialization.workspaces.save(workspace);
    const tags = blockTags ? blockTags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
    
    fetch(apiBaseUrl + "api/blocks/" + blockId, {
        method: "PUT",
        headers: {
            "Authorization": "Bearer " + jwt,
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            name: blockName,
            content: JSON.stringify(json),
            tags: tags,
            isPublic: isPublic
        })
    })
    .then(async res => {
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`Error ${res.status}: ${errorText}`);
        }
        return res.json();
    })
    .then(data => {
        currentBlock = data;
        displayBlock(data);
        status.innerText = '';
        var modal = bootstrap.Modal.getInstance(document.getElementById('updateBlockModal'));
        if (modal) modal.hide();
        document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
        document.body.classList.remove('modal-open');
        document.body.style = '';
        alert('Block updated successfully!');
    })
    .catch(err => {
        status.innerText = err.message || 'Update failed.';
    });
    return false;
}

function sendToApi() {
    const jwt = localStorage.getItem("token");
    const json = Blockly.serialization.workspaces.save(workspace);
    const statusElement = isEditMode ? document.getElementById("editApiStatus") : document.getElementById("apiStatus");
    statusElement.innerText = "";
    
    if (!jwt) {
        statusElement.innerText = "Please login first.";
        return;
    }
    
    fetch(apiBaseUrl + "api/translate", {
        method: "POST",
        headers: {
            "Authorization": "Bearer " + jwt,
            "Content-Type": "application/json"
        },
        body: JSON.stringify(json)
    })
    .then(res => {
        if (!res.ok) throw new Error("API error: " + res.status);
        return res.text();
    })
    .then(code => {
        document.getElementById("codeDisplay").innerText = code;
        statusElement.innerText = "Success!";
    })
    .catch(err => {
        statusElement.innerText = err.message || "API error";
    });
}

function cancelEdit() {
    if (originalBlockContent) {
        // Restore the original content
        Blockly.serialization.workspaces.load(originalBlockContent, workspace);
    }
    
    // Exit edit mode
    toggleEditMode();
    document.getElementById('editApiStatus').innerText = '';
}

function saveChanges() {
    const jwt = localStorage.getItem("token");
    const statusElement = document.getElementById("editApiStatus");
    statusElement.innerText = "Saving changes...";
    
    if (!jwt) {
        statusElement.innerText = "Please login first.";
        return;
    }
    
    const json = Blockly.serialization.workspaces.save(workspace);
    
    fetch(apiBaseUrl + "api/blocks/" + blockId, {
        method: "PUT",
        headers: {
            "Authorization": "Bearer " + jwt,
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            content: JSON.stringify(json)
        })
    })
    .then(async res => {
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`Error ${res.status}: ${errorText}`);
        }
        return res.json();
    })
    .then(data => {
        currentBlock = data;
        originalBlockContent = Blockly.serialization.workspaces.save(workspace);
        displayBlock(data);
        statusElement.innerText = "Changes saved successfully!";
        
        // Exit edit mode after successful save
        setTimeout(() => {
            toggleEditMode();
        }, 1500);
    })
    .catch(err => {
        statusElement.innerText = err.message || 'Save failed.';
    });
}

function openSettings() {
    if (!currentBlock) return;
    
    // Pre-fill the modal with current values
    document.getElementById('settingsBlockName').value = currentBlock.name;
    document.getElementById('settingsBlockTags').value = currentBlock.tags.join(', ');
    document.getElementById('settingsBlockPublic').checked = currentBlock.isPublic;
    document.getElementById('settingsStatus').innerText = '';
    
    var modal = new bootstrap.Modal(document.getElementById('settingsModal'));
    modal.show();
}

function submitSettings(e) {
    e.preventDefault();
    const jwt = localStorage.getItem("token");
    const blockName = document.getElementById('settingsBlockName').value;
    const blockTags = document.getElementById('settingsBlockTags').value;
    const isPublic = document.getElementById('settingsBlockPublic').checked;
    const status = document.getElementById('settingsStatus');
    status.innerText = '';
    
    if (!jwt) {
        status.innerText = 'Please login first.';
        return false;
    }
    
    const tags = blockTags ? blockTags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
    
    fetch(apiBaseUrl + "api/blocks/" + blockId, {
        method: "PUT",
        headers: {
            "Authorization": "Bearer " + jwt,
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            name: blockName,
            tags: tags,
            isPublic: isPublic
        })
    })
    .then(async res => {
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`Error ${res.status}: ${errorText}`);
        }
        return res.json();
    })
    .then(data => {
        currentBlock = data;
        displayBlock(data);
        status.innerText = '';
        var modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
        if (modal) modal.hide();
        document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
        document.body.classList.remove('modal-open');
        document.body.style = '';
        alert('Settings updated successfully!');
    })
    .catch(err => {
        status.innerText = err.message || 'Update failed.';
    });
    return false;
}

document.getElementById("copyCodeBtn").onclick = function() {
    const code = document.getElementById("codeDisplay").innerText;
    if (navigator.clipboard) {
        navigator.clipboard.writeText(code);
    } else {
        // fallback for old browsers
        const textarea = document.createElement("textarea");
        textarea.value = code;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
    }
};

// Star and Fork functionality (Phase 2 & 3)
function starBlock() {
    const jwt = localStorage.getItem("token");
    if (!jwt) {
        alert('Please login first to star blocks.');
        return;
    }

    const starBtn = document.getElementById('starBtn');
    const originalText = starBtn.innerHTML;
    starBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Starring...';
    starBtn.disabled = true;

    fetch(`${apiBaseUrl}api/blocks/${blockId}/star`, {
        method: 'POST',
        headers: {
            'Authorization': 'Bearer ' + jwt,
            'Content-Type': 'application/json'
        }
    })
    .then(async res => {
        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(errorData.message || 'Failed to star block');
        }
        return res.json();
    })
    .then(result => {
        // Update the star count in the current block
        if (currentBlock) {
            currentBlock.starCount = result.starCount;
            displayBlock(currentBlock);
        }
        
        // Update button state
        updateStarButton(result.isStarred, result.starCount);
        
        // Show success feedback
        showToast('Block starred successfully!', 'success');
    })
    .catch(err => {
        console.error('Error starring block:', err);
        starBtn.innerHTML = originalText;
        starBtn.disabled = false;
        showToast(err.message || 'Failed to star block', 'error');
    });
}

function unstarBlock() {
    const jwt = localStorage.getItem("token");
    if (!jwt) {
        alert('Please login first.');
        return;
    }

    const starBtn = document.getElementById('starBtn');
    const originalText = starBtn.innerHTML;
    starBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Unstarring...';
    starBtn.disabled = true;

    fetch(`${apiBaseUrl}api/blocks/${blockId}/star`, {
        method: 'DELETE',
        headers: {
            'Authorization': 'Bearer ' + jwt,
            'Content-Type': 'application/json'
        }
    })
    .then(async res => {
        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(errorData.message || 'Failed to unstar block');
        }
        return res.json();
    })
    .then(result => {
        // Update the star count in the current block
        if (currentBlock) {
            currentBlock.starCount = result.starCount;
            displayBlock(currentBlock);
        }
        
        // Update button state
        updateStarButton(result.isStarred, result.starCount);
        
        // Show success feedback
        showToast('Block unstarred successfully!', 'success');
    })
    .catch(err => {
        console.error('Error unstarring block:', err);
        starBtn.innerHTML = originalText;
        starBtn.disabled = false;
        showToast(err.message || 'Failed to unstar block', 'error');
    });
}

function updateStarButton(isStarred, starCount) {
    const starBtn = document.getElementById('starBtn');
    if (!starBtn) return;

    starBtn.disabled = false;
    
    if (isStarred) {
        starBtn.className = 'btn btn-warning me-2';
        starBtn.innerHTML = '<i class="bi bi-star-fill"></i> Starred (' + starCount + ')';
        starBtn.onclick = unstarBlock;
        starBtn.title = 'Unstar this block';
    } else {
        starBtn.className = 'btn btn-outline-warning me-2';
        starBtn.innerHTML = '<i class="bi bi-star"></i> Star (' + starCount + ')';
        starBtn.onclick = starBlock;
        starBtn.title = 'Star this block';
    }
}

function forkBlock() {
    const jwt = localStorage.getItem("token");
    if (!jwt) {
        alert('Please login first to fork blocks.');
        return;
    }

    if (!currentBlock || !currentBlock.id) {
        alert('Block information not available.');
        return;
    }

    // Show fork modal
    showForkModal(currentBlock.id);
}

function showForkModal(blockId) {
    const block = currentBlock;
    if (!block) return;

    const modalHTML = `
        <div class="modal fade" id="forkModal" tabindex="-1" aria-labelledby="forkModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="forkModalLabel">Fork Block</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <p>You are about to create a fork of:</p>
                        <div class="card">
                            <div class="card-body">
                                <h6 class="card-title">${escapeHtml(block.name)}</h6>
                                <p class="card-text text-muted">by ${escapeHtml(block.ownerName)}</p>
                                <small class="text-muted">
                                    <i class="bi bi-star"></i> ${block.starCount} stars • 
                                    <i class="bi bi-arrow-up-right-square"></i> ${block.forkCount} forks
                                </small>
                            </div>
                        </div>
                        <div class="mt-3">
                            <label for="forkName" class="form-label">Fork Name</label>
                            <input type="text" class="form-control" id="forkName" value="${escapeHtml(block.name)} (Fork)" placeholder="Enter name for your fork">
                        </div>
                        <div class="mt-3">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="forkPublic" checked>
                                <label class="form-check-label" for="forkPublic">
                                    Make fork public
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" onclick="performFork(${blockId})">Create Fork</button>
                    </div>
                </div>
            </div>
        </div>
    `;

    // Remove existing modal if any
    const existingModal = document.getElementById('forkModal');
    if (existingModal) {
        existingModal.remove();
    }

    // Add modal to DOM
    document.body.insertAdjacentHTML('beforeend', modalHTML);

    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('forkModal'));
    modal.show();

    // Clean up after hiding
    document.getElementById('forkModal').addEventListener('hidden.bs.modal', function() {
        this.remove();
    });
}

function performFork(blockId) {
    const jwt = localStorage.getItem("token");
    const forkName = document.getElementById('forkName').value.trim();
    const isPublic = document.getElementById('forkPublic').checked;

    if (!forkName) {
        alert('Please enter a name for your fork.');
        return;
    }

    const forkBtn = document.querySelector('.modal-footer .btn-primary');
    const originalText = forkBtn.innerHTML;
    forkBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Creating Fork...';
    forkBtn.disabled = true;

    fetch(`${apiBaseUrl}api/blocks/${blockId}/fork`, {
        method: 'POST',
        headers: {
            'Authorization': 'Bearer ' + jwt,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            name: forkName,
            isPublic: isPublic
        })
    })
    .then(async res => {
        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(errorData.message || 'Failed to fork block');
        }
        return res.json();
    })
    .then(result => {
        // Hide modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('forkModal'));
        modal.hide();
        
        // Update fork count in UI
        if (currentBlock) {
            currentBlock.forkCount = result.totalForks;
            updateForkCount(result.totalForks);
        }

        showToast('Block forked successfully!', 'success');
        
        // Optionally redirect to the new fork
        setTimeout(() => {
            if (confirm('Fork created successfully! Would you like to edit your new fork?')) {
                window.location.href = `/Home/BlockEditor?id=${result.forkId}`;
            }
        }, 1000);
    })
    .catch(err => {
        console.error('Error forking block:', err);
        forkBtn.innerHTML = originalText;
        forkBtn.disabled = false;
        showToast('Failed to fork block: ' + err.message, 'error');
    });
}

function updateForkCount(newCount) {
    const forkBtn = document.getElementById('forkBtn');
    if (forkBtn) {
        const forkText = forkBtn.innerHTML.replace(/\d+/, newCount);
        forkBtn.innerHTML = forkText;
    }
}

function showToast(message, type) {
    // Create toast element
    const toastContainer = document.getElementById('toastContainer') || createToastContainer();
    const toastId = 'toast-' + Date.now();
    const bgClass = type === 'success' ? 'bg-success' : 'bg-danger';
    
    const toastHTML = `
        <div id="${toastId}" class="toast ${bgClass} text-white" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">
                    ${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    `;
    
    toastContainer.insertAdjacentHTML('beforeend', toastHTML);
    
    // Initialize and show toast
    const toastElement = document.getElementById(toastId);
    const toast = new bootstrap.Toast(toastElement, { delay: 3000 });
    toast.show();
    
    // Remove element after hiding
    toastElement.addEventListener('hidden.bs.toast', () => {
        toastElement.remove();
    });
}

function createToastContainer() {
    const container = document.createElement('div');
    container.id = 'toastContainer';
    container.className = 'toast-container position-fixed top-0 end-0 p-3';
    container.style.zIndex = '1080';
    document.body.appendChild(container);
    return container;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// ===== REAL-TIME COMMENT SYSTEM =====
let mqttClient = null;
let comments = [];
let editingCommentId = null;
let displayedCommentsCount = 5; // Default to show 5 comments
let allComments = []; // Store all comments for filtering/sorting

function initializeCommentSystem() {
    const jwt = localStorage.getItem("token");
    
    // Show comment input if user is logged in
    if (jwt) {
        document.getElementById('commentInputSection').style.display = 'block';
        setupCommentInput();
    }
    
    // Load existing comments
    loadComments();
    
    // Initialize MQTT for real-time updates
    initializeMQTT();
}

function setupCommentInput() {
    const commentInput = document.getElementById('commentInput');
    const charCount = document.getElementById('commentCharCount');
    const submitBtn = document.getElementById('submitComment');
    
    commentInput.addEventListener('input', function() {
        const length = this.value.length;
        charCount.textContent = length;
        charCount.className = length > 900 ? 'text-danger' : length > 700 ? 'text-warning' : 'text-muted';
        submitBtn.disabled = length === 0 || length > 1000;
    });
    
    commentInput.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            e.preventDefault();
            if (!submitBtn.disabled) {
                submitComment();
            }
        }
    });
}

async function loadComments() {
    try {
        const response = await fetch(`${apiBaseUrl}api/comments/block/${blockId}`, {
            headers: {
                'Authorization': localStorage.getItem("token") ? `Bearer ${localStorage.getItem("token")}` : ''
            }
        });
        
        if (response.ok) {
            const rawComments = await response.json();
            console.log('📥 Loaded comments from API:', rawComments);
            
            // Normalize comment objects to use camelCase for frontend consistency
            allComments = rawComments.map(comment => ({
                id: comment.id || comment.Id,
                blockId: comment.blockId || comment.BlockId,
                userId: comment.userId || comment.UserId,
                userName: comment.userName || comment.UserName,
                content: comment.content || comment.Content,
                createdAt: comment.createdAt || comment.CreatedAt,
                updatedAt: comment.updatedAt || comment.UpdatedAt,
                isOwner: comment.isOwner || comment.IsOwner
            }));
            
            // Keep the legacy comments array for backward compatibility
            comments = [...allComments];
            
            console.log('✅ Normalized comments for frontend:', allComments);
            displayComments();
        } else {
            throw new Error('Failed to load comments');
        }
    } catch (error) {
        console.error('Error loading comments:', error);
        const loadingEl = document.getElementById('commentsLoading');
        if (loadingEl) {
            loadingEl.innerHTML = 
                '<div class="alert alert-danger">Failed to load comments. Please refresh the page.</div>';
        }
    }
}

function showMoreComments() {
    const limitValue = document.getElementById('commentLimit')?.value || '5';
    const increment = limitValue === 'all' ? allComments.length : parseInt(limitValue);
    
    // Increase the number of comments to display
    displayedCommentsCount += increment;
    
    // Make sure we don't exceed total comments
    if (displayedCommentsCount > allComments.length) {
        displayedCommentsCount = allComments.length;
    }
    
    // Update the display
    updateCommentDisplay();
    console.log(`📄 Now showing ${displayedCommentsCount} of ${allComments.length} comments`);
}

function displayComments() {
    // For MQTT real-time updates, use a more direct approach if elements exist
    const loadingEl = document.getElementById('commentsLoading');
    const emptyEl = document.getElementById('commentsEmpty');
    const listEl = document.getElementById('commentsList');
    
    if (loadingEl && emptyEl && listEl) {
        // Elements exist, update immediately
        updateCommentDisplay(loadingEl, emptyEl, listEl);
        console.log('✅ Comments displayed immediately (elements found)');
        return;
    }
    
    // Elements not found, wait for them with retry mechanism
    console.log('🔄 Comment DOM elements not immediately available, waiting...');
    waitForCommentElements().then(() => {
        const loadingEl = document.getElementById('commentsLoading');
        const emptyEl = document.getElementById('commentsEmpty');
        const listEl = document.getElementById('commentsList');
        
        updateCommentDisplay(loadingEl, emptyEl, listEl);
        console.log('✅ Comments displayed after waiting');
    }).catch(error => {
        console.error('❌ Failed to display comments after waiting:', error);
        
        // Fallback: try to create a minimal comment display in the comment section
        const commentCard = document.querySelector('.card .card-body');
        if (commentCard) {
            console.log('🔧 Attempting to recreate comment elements...');
            recreateCommentElements(commentCard);
        } else {
            console.error('❌ Comment card not found, cannot display comments');
        }
    });
}

function updateCommentDisplay(loadingEl, emptyEl, listEl) {
    if (!loadingEl || !emptyEl || !listEl) {
        // Fallback for elements not provided
        loadingEl = document.getElementById('commentsLoading');
        emptyEl = document.getElementById('commentsEmpty');
        listEl = document.getElementById('commentsList');
    }
    
    if (!loadingEl || !emptyEl || !listEl) {
        console.warn('⚠️ Comment display elements not found');
        return;
    }
    
    loadingEl.style.display = 'none';
    
    // Update comment count
    const commentCountEl = document.getElementById('commentCount');
    if (commentCountEl) {
        commentCountEl.textContent = allComments.length;
    }
    
    if (allComments.length === 0) {
        emptyEl.style.display = 'block';
        const showMoreSection = document.getElementById('showMoreSection');
        if (showMoreSection) showMoreSection.style.display = 'none';
        return;
    }
    
    emptyEl.style.display = 'none';
    
    // Get sorting and limit preferences
    const sortOrder = document.getElementById('commentSort')?.value || 'newest';
    const limitValue = document.getElementById('commentLimit')?.value || '5';
    
    // Sort comments based on user preference (newest first by default)
    let sortedComments;
    if (sortOrder === 'newest') {
        sortedComments = [...allComments].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    } else {
        sortedComments = [...allComments].sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
    }
    
    // Determine how many comments to show
    let commentsToShow;
    if (limitValue === 'all') {
        commentsToShow = sortedComments;
        displayedCommentsCount = sortedComments.length;
    } else {
        const limit = parseInt(limitValue);
        commentsToShow = sortedComments.slice(0, displayedCommentsCount);
    }
    
    // Show/hide "Show more" button
    const showMoreSection = document.getElementById('showMoreSection');
    const showMoreBtn = document.getElementById('showMoreBtn');
    if (showMoreSection && showMoreBtn) {
        const remaining = sortedComments.length - commentsToShow.length;
        if (remaining > 0 && limitValue !== 'all') {
            showMoreSection.style.display = 'block';
            showMoreBtn.innerHTML = `<i class="bi bi-chevron-down"></i> Show ${remaining} more comments`;
        } else {
            showMoreSection.style.display = 'none';
        }
    }
    
    // Generate HTML for comments
    const commentsHtml = commentsToShow.map(comment => createCommentHtml(comment)).join('');
    listEl.innerHTML = commentsHtml;
    
    console.log(`✅ Displayed ${commentsToShow.length} of ${sortedComments.length} total comments (showing newest first)`);
}

function recreateCommentElements(commentCard) {
    // Find existing comment list or create new one
    let commentsList = document.getElementById('commentsList');
    if (!commentsList) {
        console.log('🔧 Creating missing commentsList element');
        commentsList = document.createElement('div');
        commentsList.id = 'commentsList';
        commentCard.appendChild(commentsList);
    }
    
    // Create missing elements
    if (!document.getElementById('commentsLoading')) {
        const loadingEl = document.createElement('div');
        loadingEl.id = 'commentsLoading';
        loadingEl.className = 'text-center py-3';
        loadingEl.style.display = 'none'; // Hide loading since we're past that
        commentsList.appendChild(loadingEl);
    }
    
    if (!document.getElementById('commentsEmpty')) {
        const emptyEl = document.createElement('div');
        emptyEl.id = 'commentsEmpty';
        emptyEl.className = 'text-center text-muted py-4';
        emptyEl.innerHTML = `
            <i class="bi bi-chat" style="font-size: 2rem;"></i>
            <p class="mt-2 mb-0">No comments yet. Be the first to comment!</p>
        `;
        commentsList.appendChild(emptyEl);
    }
    
    // Now try to display comments again
    const loadingEl = document.getElementById('commentsLoading');
    const emptyEl = document.getElementById('commentsEmpty');
    const listEl = document.getElementById('commentsList');
    
    if (loadingEl && emptyEl && listEl) {
        updateCommentDisplay(loadingEl, emptyEl, listEl);
        console.log('✅ Comments displayed after recreating elements');
    } else {
        console.error('❌ Still could not create comment elements, trying emergency fallback...');
        emergencyCommentDisplay(commentCard);
    }
}

function emergencyCommentDisplay(commentCard) {
    console.log('🚨 Emergency comment display - adding comment directly to card');
    
    // Create a simple comment display as last resort
    const emergencyContainer = document.createElement('div');
    emergencyContainer.id = 'emergencyComments';
    emergencyContainer.className = 'mt-3';
    emergencyContainer.innerHTML = `
        <h6>Comments (${comments.length})</h6>
        <div id="emergencyCommentList"></div>
    `;
    
    // Remove any existing emergency container
    const existingEmergency = document.getElementById('emergencyComments');
    if (existingEmergency) {
        existingEmergency.remove();
    }
    
    commentCard.appendChild(emergencyContainer);
    
    // Display comments in emergency container
    const emergencyList = document.getElementById('emergencyCommentList');
    if (emergencyList && comments.length > 0) {
        const sortedComments = [...comments].sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
        const commentsHtml = sortedComments.map(comment => createCommentHtml(comment)).join('');
        emergencyList.innerHTML = commentsHtml;
        console.log('✅ Emergency comment display successful');
    } else if (emergencyList) {
        emergencyList.innerHTML = '<p class="text-muted">No comments yet.</p>';
    }
}

// Helper function to wait for comment DOM elements to be available
function waitForCommentElements(maxRetries = 10, delay = 200) {
    return new Promise((resolve, reject) => {
        let retries = 0;
        
        function checkElements() {
            console.log(`🔍 Checking for comment DOM elements... attempt ${retries + 1}/${maxRetries}`);
            
            const loadingEl = document.getElementById('commentsLoading');
            const emptyEl = document.getElementById('commentsEmpty');
            const listEl = document.getElementById('commentsList');
            
            // More detailed logging
            console.log('DOM element search results:', {
                commentsLoading: loadingEl ? 'FOUND' : 'NOT FOUND',
                commentsEmpty: emptyEl ? 'FOUND' : 'NOT FOUND', 
                commentsList: listEl ? 'FOUND' : 'NOT FOUND',
                documentReady: document.readyState,
                bodyHasElements: document.body.children.length
            });
            
            if (loadingEl && emptyEl && listEl) {
                console.log('✅ Comment DOM elements found after', retries, 'retries');
                resolve();
                return;
            }
            
            retries++;
            if (retries >= maxRetries) {
                console.error('❌ Comment DOM elements still not found after retries');
                
                // Detailed investigation
                const commentCard = document.querySelector('.card');
                const commentHeaders = document.querySelectorAll('h5');
                const hasCommentHeader = Array.from(commentHeaders).some(h => h.textContent.includes('Comments'));
                
                console.error('Final DOM investigation:', {
                    totalCards: document.querySelectorAll('.card').length,
                    hasCommentHeader: hasCommentHeader,
                    allIdsInPage: Array.from(document.querySelectorAll('[id]')).map(el => el.id),
                    commentCardExists: !!commentCard
                });
                
                reject(new Error(`Comment DOM elements not found after ${maxRetries} retries`));
                return;
            }
            
            console.log(`🔄 Retrying in ${delay}ms... (${retries}/${maxRetries})`);
            setTimeout(checkElements, delay);
        }
        
        // Start checking immediately
        checkElements();
    });
}

function createCommentHtml(comment) {
    const jwt = localStorage.getItem("token");
    const currentUserId = jwt ? JSON.parse(atob(jwt.split('.')[1])).nameid : null;
    const isOwner = currentUserId && currentUserId === comment.userId.toString();
    
    // Parse dates and format them in local timezone
    const createdAt = new Date(comment.createdAt);
    const updatedAt = new Date(comment.updatedAt);
    const isEdited = Math.abs(createdAt.getTime() - updatedAt.getTime()) > 1000; // More than 1 second difference
    
    // Format dates in local timezone with relative time
    const formatDate = (date) => {
        const now = new Date();
        const diffInSeconds = Math.floor((now - date) / 1000);
        
        if (diffInSeconds < 60) return 'Just now';
        if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
        if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
        if (diffInSeconds < 604800) return `${Math.floor(diffInSeconds / 86400)}d ago`;
        
        // For older comments, show the full date in local timezone
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    };
    
    return `
        <div class="comment mb-3 p-3 border rounded" data-comment-id="${comment.id}">
            <div class="d-flex justify-content-between align-items-start mb-2">
                <div class="d-flex align-items-center">
                    <strong class="me-2">${escapeHtml(comment.userName)}</strong>
                    <small class="text-muted" title="${createdAt.toLocaleString()}">
                        ${formatDate(createdAt)}
                        ${isEdited ? `<i class="bi bi-pencil ms-1" title="Edited ${formatDate(updatedAt)}"></i>` : ''}
                    </small>
                </div>
                ${isOwner ? `
                    <div class="dropdown">
                        <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown">
                            <i class="bi bi-three-dots"></i>
                        </button>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="#" onclick="editComment(${comment.id})">
                                <i class="bi bi-pencil"></i> Edit
                            </a></li>
                            <li><a class="dropdown-item text-danger" href="#" onclick="deleteComment(${comment.id})">
                                <i class="bi bi-trash"></i> Delete
                            </a></li>
                        </ul>
                    </div>
                ` : ''}
            </div>
            <div class="comment-content">
                <p class="mb-0 comment-text">${escapeHtml(comment.content).replace(/\n/g, '<br>')}</p>
                <div class="comment-edit-form" style="display: none;">
                    <textarea class="form-control mb-2" rows="3" maxlength="1000">${escapeHtml(comment.content)}</textarea>
                    <div class="d-flex justify-content-end">
                        <button class="btn btn-sm btn-outline-secondary me-2" onclick="cancelEditComment(${comment.id})">Cancel</button>
                        <button class="btn btn-sm btn-primary" onclick="saveEditComment(${comment.id})">Save</button>
                    </div>
                </div>
            </div>
        </div>
    `;
}

async function submitComment() {
    const jwt = localStorage.getItem("token");
    if (!jwt) {
        alert('Please login to comment');
        return;
    }
    
    const content = document.getElementById('commentInput').value.trim();
    if (!content) return;
    
    const submitBtn = document.getElementById('submitComment');
    const originalText = submitBtn.innerHTML;
    submitBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Posting...';
    submitBtn.disabled = true;
    
    try {
        const response = await fetch(`${apiBaseUrl}api/comments`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${jwt}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                blockId: blockId,
                content: content
            })
        });
        
        if (response.ok) {
            document.getElementById('commentInput').value = '';
            document.getElementById('commentCharCount').textContent = '0';
            document.getElementById('commentStatus').innerHTML = 
                '<div class="alert alert-success alert-dismissible fade show" role="alert">Comment posted successfully!</div>';
            
            // Clear success message after 3 seconds
            setTimeout(() => {
                const alert = document.querySelector('#commentStatus .alert');
                if (alert) alert.remove();
            }, 3000);
            
            // Auto-scroll to bottom after a short delay to ensure the comment appears
            setTimeout(() => {
                scrollToBottomOfComments();
            }, 500);
        } else {
            throw new Error('Failed to post comment');
        }
    } catch (error) {
        console.error('Error posting comment:', error);
        document.getElementById('commentStatus').innerHTML = 
            '<div class="alert alert-danger">Failed to post comment. Please try again.</div>';
    } finally {
        submitBtn.innerHTML = originalText;
        submitBtn.disabled = false;
    }
}

function scrollToBottomOfComments() {
    const commentsList = document.getElementById('commentsList') || document.getElementById('emergencyCommentList');
    if (commentsList) {
        // Find the last comment element
        const comments = commentsList.querySelectorAll('.comment, [data-comment-id]');
        if (comments.length > 0) {
            const lastComment = comments[comments.length - 1];
            lastComment.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'end' 
            });
            console.log('📍 Auto-scrolled to bottom of comments');
        } else {
            // Fallback: scroll the comments list container
            commentsList.scrollTop = commentsList.scrollHeight;
        }
    }
}

function editComment(commentId) {
    const commentEl = document.querySelector(`[data-comment-id="${commentId}"]`);
    const textEl = commentEl.querySelector('.comment-text');
    const editEl = commentEl.querySelector('.comment-edit-form');
    
    textEl.style.display = 'none';
    editEl.style.display = 'block';
    editEl.querySelector('textarea').focus();
    editingCommentId = commentId;
}

function cancelEditComment(commentId) {
    const commentEl = document.querySelector(`[data-comment-id="${commentId}"]`);
    const textEl = commentEl.querySelector('.comment-text');
    const editEl = commentEl.querySelector('.comment-edit-form');
    
    textEl.style.display = 'block';
    editEl.style.display = 'none';
    editingCommentId = null;
}

async function saveEditComment(commentId) {
    const jwt = localStorage.getItem("token");
    if (!jwt) {
        alert('Please login to edit comments');
        return;
    }
    
    const commentEl = document.querySelector(`[data-comment-id="${commentId}"]`);
    const textarea = commentEl.querySelector('textarea');
    const content = textarea.value.trim();
    
    if (!content) {
        alert('Comment cannot be empty');
        return;
    }
    
    const saveBtn = commentEl.querySelector('.btn-primary');
    const originalText = saveBtn.innerHTML;
    saveBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Saving...';
    saveBtn.disabled = true;
    
    try {
        const response = await fetch(`${apiBaseUrl}api/comments/${commentId}`, {
            method: 'PUT',
            headers: {
                'Authorization': `Bearer ${jwt}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: content
            })
        });
        
        if (response.ok) {
            cancelEditComment(commentId);
        } else {
            throw new Error('Failed to update comment');
        }
    } catch (error) {
        console.error('Error updating comment:', error);
        alert('Failed to update comment. Please try again.');
    } finally {
        saveBtn.innerHTML = originalText;
        saveBtn.disabled = false;
    }
}

async function deleteComment(commentId) {
    if (!confirm('Are you sure you want to delete this comment? This action cannot be undone.')) {
        return;
    }
    
    const jwt = localStorage.getItem("token");
    if (!jwt) {
        alert('Please login to delete comments');
        return;
    }
    
    try {
        const response = await fetch(`${apiBaseUrl}api/comments/${commentId}`, {
            method: 'DELETE',
            headers: {
                'Authorization': `Bearer ${jwt}`
            }
        });
        
        if (response.ok) {
            // Comment will be removed via MQTT real-time update
        } else {
            throw new Error('Failed to delete comment');
        }
    } catch (error) {
        console.error('Error deleting comment:', error);
        alert('Failed to delete comment. Please try again.');
    }
}

function cancelComment() {
    document.getElementById('commentInput').value = '';
    document.getElementById('commentCharCount').textContent = '0';
    document.getElementById('submitComment').disabled = true;
}

// ===== MQTT REAL-TIME UPDATES =====
function initializeMQTT() {
    try {
        // Generate unique client ID
        const clientId = `SyntaxFlow_Client_${Math.random().toString(36).substr(2, 9)}`;
        
        // Connect to MQTT broker using secure WebSocket for HTTPS pages
        const brokerUrl = location.protocol === 'https:' ? 'wss://broker.emqx.io:8084/mqtt' : 'ws://broker.emqx.io:8083/mqtt';
        
        console.log(`🔄 Initializing MQTT connection:`, {
            protocol: location.protocol,
            brokerUrl: brokerUrl,
            clientId: clientId,
            blockId: blockId
        });
        
        // Check if mqtt library is available
        if (typeof mqtt === 'undefined') {
            console.warn('⚠️ MQTT library not loaded, skipping real-time updates');
            return;
        }
        
        mqttClient = mqtt.connect(brokerUrl, {
            clientId: clientId,
            clean: true,
            connectTimeout: 10000,
            reconnectPeriod: 5000
        });
        
        mqttClient.on('connect', onMQTTConnect);
        mqttClient.on('error', onMQTTError);
        mqttClient.on('close', onMQTTConnectionLost);
        mqttClient.on('message', onMQTTMessageArrived);
        
    } catch (error) {
        console.error('❌ Error initializing MQTT:', error);
        // Continue without real-time updates
    }
}

function onMQTTConnect() {
    console.log('✅ Connected to MQTT broker for real-time comments');
    
    // Subscribe to comment topics for this block
    const blockTopic = `syntaxflow/comments/${blockId}`;
    const deleteTopic = 'syntaxflow/comments/deleted';
    
    console.log(`📡 Subscribing to topics: ${blockTopic} and ${deleteTopic}`);
    
    mqttClient.subscribe(blockTopic, (err) => {
        if (err) {
            console.error('❌ Failed to subscribe to block topic:', err);
        } else {
            console.log(`✅ Subscribed to: ${blockTopic}`);
        }
    });
    
    mqttClient.subscribe(deleteTopic, (err) => {
        if (err) {
            console.error('❌ Failed to subscribe to delete topic:', err);
        } else {
            console.log(`✅ Subscribed to: ${deleteTopic}`);
        }
    });
}

function onMQTTError(error) {
    console.warn('⚠️ MQTT connection error:', error);
    // Continue without real-time updates
}

function onMQTTConnectionLost() {
    console.warn('🔌 MQTT connection lost, will attempt to reconnect automatically');
    // mqtt.js handles reconnection automatically
}

function onMQTTMessageArrived(topic, message) {
    try {
        const payload = JSON.parse(message.toString());
        console.log('📥 Received MQTT message:', {
            topic: topic,
            action: payload.action,
            payload: payload
        });
        
        switch (payload.action) {
            case 'create':
                console.log('🆕 Handling new comment:', payload.comment);
                handleNewComment(payload.comment);
                break;
            case 'update':
                console.log('✏️ Handling comment update:', payload.comment);
                handleUpdatedComment(payload.comment);
                break;
            case 'delete':
                console.log('🗑️ Handling comment deletion:', payload.commentId);
                handleDeletedComment(payload.commentId);
                break;
            default:
                console.warn('❓ Unknown MQTT action:', payload.action);
        }
    } catch (error) {
        console.error('❌ Error processing MQTT message:', error);
    }
}

function handleNewComment(comment) {
    // Handle both camelCase and PascalCase property names for backward compatibility
    const commentBlockId = comment.blockId || comment.BlockId;
    const commentId = comment.id || comment.Id;
    
    console.log(`🔍 Processing new comment:`, {
        comment: comment,
        extractedBlockId: commentBlockId,
        extractedId: commentId,
        currentBlockId: blockId
    });
    
    // Only add if it's for this block and not already in the list
    if (commentBlockId === blockId && !allComments.find(c => (c.id || c.Id) === commentId)) {
        console.log(`➕ Adding new comment to UI - CommentId: ${commentId}, BlockId: ${commentBlockId}`);
        
        // Normalize the comment object to use camelCase for frontend consistency
        const normalizedComment = {
            id: commentId,
            blockId: commentBlockId,
            userId: comment.userId || comment.UserId,
            userName: comment.userName || comment.UserName,
            content: comment.content || comment.Content,
            createdAt: comment.createdAt || comment.CreatedAt,
            updatedAt: comment.updatedAt || comment.UpdatedAt,
            isOwner: comment.isOwner || comment.IsOwner
        };
        
        // Add to both arrays for consistency
        allComments.push(normalizedComment);
        comments.push(normalizedComment);
        
        // Debug: Check DOM state when MQTT message arrives
        console.log('🔧 DOM state at MQTT message time:', {
            readyState: document.readyState,
            hasCommentsList: !!document.getElementById('commentsList'),
            hasCommentsLoading: !!document.getElementById('commentsLoading'),
            hasCommentsEmpty: !!document.getElementById('commentsEmpty'),
            allCommentElements: document.querySelectorAll('[id*="comment"]').length,
            totalElementsWithId: document.querySelectorAll('[id]').length
        });
        
        // Try immediate display first, then fallback to waiting
        displayComments();
        
        // Highlight the new comment after a short delay
        setTimeout(() => highlightNewComment(commentId), 100);
        
        // Show notification with scroll functionality
        showCommentNotification('New comment added', 'success', commentId);
    } else {
        console.log(`⚠️ Skipping comment - wrong block or already exists:`, {
            commentBlockId: commentBlockId,
            currentBlockId: blockId,
            alreadyExists: !!allComments.find(c => (c.id || c.Id) === commentId),
            blockIdMatch: commentBlockId === blockId
        });
    }
}

function handleUpdatedComment(comment) {
    // Handle both camelCase and PascalCase property names from backend
    const commentBlockId = comment.blockId || comment.BlockId;
    const commentId = comment.id || comment.Id;
    
    if (commentBlockId === blockId) {
        // Update in both arrays
        const allIndex = allComments.findIndex(c => (c.id || c.Id) === commentId);
        const commentsIndex = comments.findIndex(c => (c.id || c.Id) === commentId);
        
        if (allIndex !== -1 || commentsIndex !== -1) {
            console.log(`✏️ Updating comment in UI - CommentId: ${commentId}, BlockId: ${commentBlockId}`);
            
            // Normalize the comment object to use camelCase for frontend consistency
            const normalizedComment = {
                id: commentId,
                blockId: commentBlockId,
                userId: comment.userId || comment.UserId,
                userName: comment.userName || comment.UserName,
                content: comment.content || comment.Content,
                createdAt: comment.createdAt || comment.CreatedAt,
                updatedAt: comment.updatedAt || comment.UpdatedAt,
                isOwner: comment.isOwner || comment.IsOwner
            };
            
            if (allIndex !== -1) allComments[allIndex] = normalizedComment;
            if (commentsIndex !== -1) comments[commentsIndex] = normalizedComment;
            
            displayComments();
            showCommentNotification('Comment updated', 'info');
        } else {
            console.warn(`⚠️ Comment to update not found - CommentId: ${commentId}`);
        }
    } else {
        console.log(`⚠️ Ignoring comment update for different block - CommentBlockId: ${commentBlockId}, CurrentBlockId: ${blockId}`);
    }
}

function handleDeletedComment(commentId) {
    // Remove from both arrays
    const allIndex = allComments.findIndex(c => c.id === commentId);
    const commentsIndex = comments.findIndex(c => c.id === commentId);
    
    if (allIndex !== -1 || commentsIndex !== -1) {
        console.log(`🗑️ Removing comment from UI - CommentId: ${commentId}`);
        
        if (allIndex !== -1) allComments.splice(allIndex, 1);
        if (commentsIndex !== -1) comments.splice(commentsIndex, 1);
        
        displayComments();
        showCommentNotification('Comment deleted', 'warning');
    } else {
        console.log(`⚠️ Comment to delete not found in local list - CommentId: ${commentId}`);
    }
}

function showCommentNotification(message, type, commentId = null) {
    const notification = document.createElement('div');
    notification.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
    notification.style.cssText = 'top: 20px; right: 20px; z-index: 1050; min-width: 250px;';
    
    // Make notification clickable if commentId is provided
    const clickableClass = commentId ? 'cursor-pointer' : '';
    const clickableTitle = commentId ? 'Click to scroll to comment' : '';
    
    notification.innerHTML = `
        <div class="${clickableClass}" title="${clickableTitle}">
            ${message}
            ${commentId ? '<br><small class="text">Click to scroll to comment</small>' : ''}
        </div>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="alert"></button>
    `;
    
    // Add click handler to scroll to comment
    if (commentId) {
        notification.style.cursor = 'pointer';
        notification.addEventListener('click', (e) => {
            // Don't trigger on close button click
            if (!e.target.classList.contains('btn-close')) {
                scrollToComment(commentId);
                // Dismiss notification after clicking
                notification.remove();
            }
        });
    }
    
    document.body.appendChild(notification);
    
    // Auto-remove after 5 seconds (increased from 3 to give more time to click)
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 5000);
}

function scrollToComment(commentId) {
    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    if (commentElement) {
        // Scroll to the comment with smooth behavior
        commentElement.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center' 
        });
        
        // Highlight the comment briefly
        highlightNewComment(commentId);
        
        console.log(`📍 Scrolled to comment ${commentId}`);
    } else {
        console.warn(`⚠️ Comment element not found for ID: ${commentId}`);
    }
}

function highlightNewComment(commentId) {
    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    if (commentElement) {
        // Add highlight class with animation
        commentElement.style.transition = 'background-color 0.3s ease';
        commentElement.style.backgroundColor = '#fff3cd'; // Light yellow highlight
        commentElement.style.border = '2px solid #ffc107'; // Yellow border
        
        // Remove highlight after 3 seconds
        setTimeout(() => {
            commentElement.style.backgroundColor = '';
            commentElement.style.border = '1px solid #dee2e6'; // Original border
            
            // Remove transition after animation
            setTimeout(() => {
                commentElement.style.transition = '';
            }, 300);
        }, 3000);
        
        console.log(`✨ Highlighted comment ${commentId}`);
    } else {
        console.warn(`⚠️ Could not highlight comment: element not found for ID ${commentId}`);
    }
}

// Clean up MQTT connection when page unloads
window.addEventListener('beforeunload', function() {
    if (mqttClient && mqttClient.connected) {
        mqttClient.end();
    }
});
</script>

<!-- Bootstrap Icons -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<!-- MQTT Client for real-time comments -->
<script src="https://unpkg.com/mqtt@5.0.5/dist/mqtt.min.js"></script>
